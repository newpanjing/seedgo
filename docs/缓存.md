# 缓存 (Cache)

项目提供了一个统一的缓存接口 `pkg/cache`，支持多种后端实现（目前支持 `Memory` 和 `Redis`），并内置了 JSON 序列化/反序列化机制，使用户无需关心底层存储细节，即可方便地缓存结构体、基本类型等数据。

如果项目部署了2台及以上，必须使用`redis`作为缓存后端，不能使用内存缓存，否则会造成角色、权限相关问题。

## 核心特性

*   **统一接口**: 无论底层是内存还是 Redis，业务代码无需修改。
*   **自动序列化**: 支持存储 struct、map、slice、string、int 等任意类型，底层自动转为 JSON 存储。
*   **Context 支持**: 所有方法均支持 `context.Context`，便于超时控制和链路追踪。
*   **TTL 支持**: 支持设置过期时间。

## 接口定义

```go
type Cache interface {
    // Set 设置缓存
    // value: 支持任意类型
    // ttl: 过期时间，0 表示永不过期
    Set(ctx context.Context, key string, value any, ttl time.Duration) error

    // Get 获取缓存
    // dest: 接收值的变量指针 (e.g. &user)
    Get(ctx context.Context, key string, dest any) error

    // Del 删除缓存
    Del(ctx context.Context, key string) error

    // Has 判断是否存在
    Has(ctx context.Context, key string) (bool, error)

    // Clear 清空缓存 (慎用)
    Clear(ctx context.Context) error
}
```

## 初始化

使用 `cache.NewCache` 工厂方法创建实例。

### 1. 内存模式 (Memory)

适合本地开发、测试或单机非持久化缓存。

```go
import "seedgo/pkg/cache"

c, err := cache.NewCache(cache.Config{
    Type: cache.TypeMemory,
})
```

### 2. Redis 模式

适合生产环境、分布式缓存。需要引入 `github.com/redis/go-redis/v9`。

```go
import (
    "seedgo/pkg/cache"
    "github.com/redis/go-redis/v9"
)

c, err := cache.NewCache(cache.Config{
    Type: cache.TypeRedis,
    RedisOption: &redis.Options{
        Addr:     "localhost:6379",
        Password: "", // no password set
        DB:       0,  // use default DB
    },
})
```

## 使用示例

### 缓存基本类型

```go
ctx := context.Background()

// 设置字符串
err := c.Set(ctx, "verify_code:13800138000", "123456", 5*time.Minute)

// 获取字符串
var code string
err = c.Get(ctx, "verify_code:13800138000", &code)
if err != nil {
    // 处理 cache miss 或其他错误
}
```

### 缓存结构体 (推荐)

系统会自动将对象序列化为 JSON 字符串存储，取出时自动反序列化。

```go
type UserInfo struct {
    ID       int    `json:"id"`
    Username string `json:"username"`
    Role     string `json:"role"`
}

// ...

user := UserInfo{ID: 1, Username: "admin", Role: "super_admin"}

// 1. 存入缓存 (设置 1 小时过期)
err := c.Set(ctx, "user:info:1", user, 1*time.Hour)
if err != nil {
    log.Println("Set cache failed:", err)
}

// 2. 读取缓存
var cachedUser UserInfo
err = c.Get(ctx, "user:info:1", &cachedUser)

if err == cache.ErrCacheMiss {
    log.Println("Cache miss, load from DB...")
    // load from db...
} else if err != nil {
    log.Println("Cache error:", err)
} else {
    fmt.Printf("Get user from cache: %+v\n", cachedUser)
}
```

### 检查与删除

```go
// 检查 key 是否存在
exists, _ := c.Has(ctx, "user:info:1")
if exists {
    // ...
}

// 删除 key
_ = c.Del(ctx, "user:info:1")
```

## 最佳实践

1.  **Key 命名**: 建议使用冒号分隔的命名空间，例如 `module:resource:id` (如 `auth:token:xyz`, `system:config:app_name`)。
2.  **Dest 指针**: `Get` 方法的 `dest` 参数必须是**指针**，否则无法赋值。
3.  **错误处理**: 建议判断 `cache.ErrCacheMiss` 来区分“系统错误”和“缓存未命中”。

```